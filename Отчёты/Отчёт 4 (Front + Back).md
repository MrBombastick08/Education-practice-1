# Отчет по интеграции Front-end и Back-end

## 1. Введение

Данный отчет анализирует механизмы взаимодействия между серверной частью (Back-end, Flask) и клиентской частью (Front-end, HTML/Jinja2/CSS/JS) проекта "Управление производством". Интеграция построена на классической архитектуре **Model-View-Controller (MVC)**, где Flask выступает в роли контроллера, SQLAlchemy — модели, а Jinja2-шаблоны — представления.

## 2. Основной механизм интеграции: Jinja2

Ключевым инструментом для связывания Back-end и Front-end является шаблонизатор **Jinja2**.

### 2.1. Передача данных в шаблоны

Back-end (в файле `app.py`) извлекает данные из базы данных с помощью SQLAlchemy и передает их в шаблоны через функцию `render_template()`.

| Маршрут | Извлекаемые данные | Шаблон | Пример передачи |
| :--- | :--- | :--- | :--- |
| `/products` | Список продукции (`Product.query.all()`), рассчитанное время производства. | `products.html` | `render_template('products.html', products=all_products, production_times=...)` |
| `/product/workshops/<id>` | Детали продукта, список связанных цехов, общее время производства. | `workshops.html` | `render_template('workshops.html', product=product, workshops=...)` |
| `/material-calculator` | Форма (`MaterialCalculatorForm`), результат расчета, списки типов продукции и материалов. | `material_calculator.html` | `render_template('material_calculator.html', form=form, result=result, ...)` |

### 2.2. Динамическая генерация HTML

Внутри шаблонов Jinja2 используется для:
*   **Отображения данных:** Циклы `{% for product in products %}` для вывода списков и прямое обращение к переменным (`{{ product.name }}`).
*   **Условного отображения:** Блоки `{% if result %}` для показа результатов расчета или `{% with messages = get_flashed_messages(with_categories=true) %}` для вывода уведомлений.
*   **Навигации:** Функция `url_for()` используется для генерации корректных URL-адресов, что обеспечивает гибкость и независимость от структуры маршрутов.

## 3. Взаимодействие через формы (Flask-WTF)

Интеграция пользовательского ввода с Back-end осуществляется через механизм форм, реализованный с помощью расширения **Flask-WTF**.

### 3.1. Передача данных с Front-end на Back-end

1.  **Front-end:** Пользователь заполняет форму (например, на странице `/product/add`) и отправляет ее методом `POST`.
2.  **Back-end (`app.py`):**
    *   Объект формы (`form = ProductForm()`) создается и автоматически заполняется данными из `request.form`.
    *   Метод `form.validate_on_submit()` выполняет валидацию данных на стороне сервера.
    *   Если валидация успешна, данные извлекаются (`form.article.data`, `form.name.data`) и используются для создания или обновления записей в базе данных.

### 3.2. Валидация и обратная связь

*   **Валидация:** Правила валидации (например, `DataRequired`, `Length`) определены в классе формы (в файле `forms.py`).
*   **Обратная связь:**
    *   При ошибке валидации, Back-end повторно отображает шаблон, передавая в него объект формы. Jinja2 автоматически выводит сообщения об ошибках рядом с соответствующими полями.
    *   Для системных сообщений (успешное добавление, ошибка сервера) используется механизм **Flash-сообщений** (`flash('Сообщение', 'категория')`), которые отображаются в `base.html`.

## 4. Взаимодействие в Калькуляторе Сырья

Маршрут `/material-calculator` является ярким примером полного цикла интеграции:

1.  **GET-запрос:** Back-end извлекает списки `ProductType` и `MaterialType` из БД и передает их в шаблон `material_calculator.html` для заполнения выпадающих списков формы.
2.  **POST-запрос:** Пользователь отправляет форму.
3.  **Back-end:** Данные формы передаются в функцию бизнес-логики `calculate_raw_material` (из `services.py`).
4.  **Обработка:** Функция выполняет расчет и возвращает результат (число) или код ошибки (`-1`).
5.  **Ответ:** Back-end передает результат (`result`) обратно в шаблон, который условно отображает его в блоке `.result-container`.

## 5. Клиентская логика (JavaScript)

Взаимодействие на стороне клиента минимально и не включает асинхронные запросы (AJAX) для обмена данными. JavaScript используется исключительно для улучшения пользовательского опыта (UX):

*   **Подтверждение удаления:** Скрипт перехватывает нажатие кнопки "Удалить" и требует подтверждения, прежде чем отправить `POST`-запрос на Back-end.
*   **Адаптивность:** Скрипт в `base.html` динамически корректирует высоту бокового меню (`.sidebar`) при загрузке и изменении размера окна, обеспечивая корректное отображение макета.

## 6. Вывод

Интеграция Front-end и Back-end в проекте "Управление производством" реализована по классической схеме **серверного рендеринга** (Server-Side Rendering). Back-end полностью контролирует генерацию HTML-страниц, используя Jinja2 для встраивания динамических данных. Flask-WTF обеспечивает надежный и безопасный канал для передачи пользовательского ввода на сервер. Отсутствие сложной AJAX-логики делает приложение простым, надежным и легким для отладки, что идеально соответствует задачам небольшого производственного учета.
