# Отчет по Back-end части проекта

## 1. Введение

Данный отчет описывает архитектуру и ключевые компоненты Back-end части веб-приложения, разработанного для управления производственными процессами. Back-end отвечает за обработку запросов, управление данными, хранящимися в базе данных, и реализацию основной бизнес-логики, включая сложные расчеты.

## 2. Технологический стек

Back-end проекта построен на базе фреймворка **Flask** и использует следующие ключевые технологии:

| Компонент | Технология | Назначение |
| :--- | :--- | :--- |
| **Веб-фреймворк** | `Flask` | Микрофреймворк для быстрой разработки веб-приложений. |
| **База данных** | `PostgreSQL` (предположительно) | Реляционная СУБД для надежного хранения данных. |
| **ORM** | `Flask-SQLAlchemy` | Инструмент для работы с базой данных через Python-объекты (модели). |
| **Формы** | `Flask-WTF` | Инструмент для создания и валидации веб-форм. |
| **Конфигурация** | `python-dotenv` | Управление переменными окружения и настройками приложения. |

## 3. Структура файлов

Приложение следует принципу модульности и разделено на три основных файла, каждый из которых выполняет свою роль:

| Файл | Роль | Описание |
| :--- | :--- | :--- |
| **`app.py`** | **Контроллер/Маршрутизатор** | Инициализация приложения, конфигурация, определение URL-маршрутов (роутинг) и обработка HTTP-запросов. |
| **`models.py`** | **Модели данных** | Определение структуры базы данных (таблиц) с помощью классов SQLAlchemy. |
| **`services.py`** | **Бизнес-логика** | Содержит чистые функции для выполнения сложных расчетов и операций, не связанных напрямую с HTTP-запросами или БД. |

## 5. Бизнес-логика (`services.py`)

Файл `services.py` инкапсулирует две ключевые функции, реализующие основную логику производственного учета:

### 5.1. `calculate_production_time(product_id)`

**Назначение:** Рассчитывает общее время, необходимое для производства одного изделия.

**Логика:**
1.  Выполняет запрос к базе данных с использованием функции агрегации `func.sum()`.
2.  Суммирует значения поля `time_in_workshop` из таблицы `product_workshops` для всех записей, связанных с данным `product_id`.
3.  Возвращает округленное общее время.

### 5.2. `calculate_raw_material(product_type_id, material_type_id, quantity, param1, param2)`

**Назначение:** Рассчитывает необходимое количество сырья с учетом потерь.

**Логика:**
1.  **Валидация:** Проверяет существование типов продукции и материала, а также положительность входных параметров (`quantity`, `param1`, `param2`).
2.  **Получение коэффициентов:** Извлекает `coefficient` (коэффициент расхода) из `ProductType` и `waste_percentage` (процент потерь) из `MaterialType`.
3.  **Исправление типов:** Для обеспечения корректного умножения, значения `coefficient` и `waste_percentage` явно преобразуются в `float`.
4.  **Основной расчет:**
    *   `area = param1 * param2` (Базовая площадь/объем).
    *   `base_material = area * float(coefficient)` (Базовое количество сырья).
    *   `waste_factor = 1.0 + material_loss` (Коэффициент потерь).
    *   `total_material = base_material * waste_factor * quantity` (Итоговое количество с учетом потерь и объема заказа).
5.  **Округление:** Результат округляется вверх до целого числа (`int(total_material + 0.999)`), что является стандартной практикой для учета сырья.

## 6. Вывод

Back-end проекта демонстрирует четкое разделение ответственности (MVC-подобная структура), где `app.py` выступает в роли контроллера, `models.py` — модели, а `services.py` — сервисного слоя. Использование Flask и SQLAlchemy обеспечивает гибкость и масштабируемость, а вынесение сложной бизнес-логики в отдельный модуль `services.py` делает код чистым, тестируемым и легко поддерживаемым.
